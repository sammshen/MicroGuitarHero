import SwiftUI
import AVFoundation
import ORSSerial
import Foundation

struct ContentView: View {
    @StateObject private var audioManager = AudioManager()
    @State private var notesOnScreen: [Note] = []
    @State private var notesBeingPlayed: [UInt8] = []
    @State private var pressedKeys: Set<Int> = []
    @State private var showStartButton = true
    @State private var activeWaveIndex = 0
    @StateObject private var guitarPick = GuitarPick()
    @StateObject private var fretBoard = FretBoard()
    
    @State private var selectedTrack: String
    @State private var backgroundDelay: TimeInterval
    @State private var noteFallingSpeed: Double
    @State private var startDelay: TimeInterval
    @State private var speedUpFactor: Double
    @State private var noteWaves: [(id: UUID, keys: [Int], noteDuration: Double, midiNotes: [UInt8], semitoneBend: Int)]
    
    // Default is "teen"
    init() {
        _selectedTrack = State(initialValue: teen_back)
        _backgroundDelay = State(initialValue: teen_bdelay)
        _noteFallingSpeed = State(initialValue: teen_nfspeed)
        _startDelay = State(initialValue: teen_sdelay)
        _speedUpFactor = State(initialValue: teen_spfactor)
        _noteWaves = State(initialValue: teen_spirit)
    }
    // song = "boh"
    // speed = 2.38
    // offset = 8.6
    // song = "teen"
    // speed = 1.9715
    // offset = 1.25
    // song = "time"
    // speed = 2.2358
    // offset = 15.93
    
    // Song Configuration:

    // Smells like Teen Spirit
    let teen_bdelay: TimeInterval = 2
    let teen_nfspeed: Double = 7.2
    let teen_sdelay: TimeInterval = 1.25
    let teen_spfactor: Double = 1.9715
    let teen_back = "teen_back" // mp3
    
    // Bohemian Rhapsody
    let boh_bdelay: TimeInterval = 0
    let boh_nfspeed: Double = 7.2
    let boh_sdelay: TimeInterval = 4.6
    let boh_spfactor: Double = 2
    let bohemian_back = "bohemian_back" // mp3

    // Time
    let time_bdelay: TimeInterval = 0
    let time_nfspeed: Double = 7.2
    let time_sdelay: TimeInterval = 11.93
    let time_spfactor: Double = 2.2358
    let time_back = "time_back" // mp3
    
    // Volume of the notes generated by air guitar
    let loudness: UInt8 = 100
    
    var body: some View {
        ZStack {
            Color.black.edgesIgnoringSafeArea(.all)

            // Falling notes
            ForEach(notesOnScreen) { note in
                Rectangle()
                    .fill(noteColors[note.xIndex])
                    .frame(width: 30, height: 30)
                    .position(x: note.x, y: note.y)
            }

            // Key press indicators
            HStack(spacing: 80) {
                ForEach(1...4, id: \.self) { key in
                    Rectangle()
                        .fill(pressedKeys.contains(key) ? noteColors[key - 1].opacity(0.7) : noteColors[key - 1].opacity(0.3))
                        .frame(width: 50, height: 50)
                        .border(Color.white, width: 2)
                }
            }
            .frame(width: 480, height: 100)
            .position(x: 240, y: 500)

            // Start Button
            if showStartButton {
                VStack(spacing: 15) { // Adds consistent spacing
                    Text("[1]: Smells like Teen Spirit")
                        .font(.system(size: 22, weight: .bold))
                        .foregroundColor(selectedTrack == teen_back ? .yellow : .white)

                    Text("[2]: Bohemian Rhapsody")
                        .font(.system(size: 22, weight: .bold))
                        .foregroundColor(selectedTrack == bohemian_back ? .yellow : .white)

                    Text("[3]: Time         ")
                        .font(.system(size: 22, weight: .bold))
                        .foregroundColor(selectedTrack == time_back ? .yellow : .white)

                    Text("Press Start or Press the \nBIG RED BUTTON\n to Play Music")
                        .font(.system(size: 18, weight: .semibold))
                        .multilineTextAlignment(.center)
                        .foregroundColor(.white)
                        .padding(.top, 10)

                    Button(action: {
                        showStartButton = false
                        startGame()
                    }) {
                        Text("Start")
                            .font(.title)
                            .padding(.vertical, 10)
                            .padding(.horizontal, 30)
                            .background(Color.white)
                            .foregroundColor(.black)
                            .clipShape(RoundedRectangle(cornerRadius: 10))
                            .shadow(radius: 5)
                    }
                }
                .frame(maxWidth: 300) // Ensures text alignment is centered
                .padding(.top, -100)
            }

        }
        .onAppear {
            Timer.scheduledTimer(withTimeInterval: 0.05, repeats: true) { _ in
                updateNotes()
            }
        }
        .onAppear {
            NSEvent.addLocalMonitorForEvents(matching: .keyDown) { event in
                handleKeyPress(event)
                return nil
            }
            NSEvent.addLocalMonitorForEvents(matching: .keyUp) { event in
                handleKeyRelease(event)
                return nil
            }
        }
        .onAppear {
            guitarPick.onStrum = {
                print("received strum!")
                checkAndPlayWave()
            }
            
            fretBoard.onKeyChange = { key, isPressed in
                if isPressed {
                    pressedKeys.insert(key)
                } else {
                    pressedKeys.remove(key)
                    releaseNotes()
                }
                print("ðŸŽ¸ Fretboard updated pressedKeys: \(pressedKeys)")
            }
        }
        .onAppear {
            fretBoard.onBendChange = { bend in
                audioManager.setBendValue(bend)
            }
        }
    }

    func startGame() {
        notesOnScreen.removeAll()
        showStartButton = false
        activeWaveIndex = 0
        
        let formattedDelay = String(format: "%.2f", startDelay)
        print("ðŸŽµ Starting Game with note startDelay: \(formattedDelay) seconds")

        
        DispatchQueue.main.asyncAfter(deadline: .now() + backgroundDelay) {
            audioManager.stopBackgroundMusic()
            audioManager.playBackgroundMusic(selectedTrack)
        }
        startNoteWaves()
    }
    
    func startNoteWaves() {
        func scheduleWave(at index: Int) {
            guard index < noteWaves.count else { return } // Stop when we run out of waves

            let wave = noteWaves[index]
            
            // Play Note!
            for key in wave.keys {
                guard key - 1 >= 0 && key - 1 < notePositions.count else { continue }

                let newNote = Note(x: notePositions[key - 1], y: 0, speed: noteFallingSpeed, waveID: wave.id, xIndex: key - 1)

                DispatchQueue.main.async {
                    notesOnScreen.append(newNote)
                }
            }
            
            // schedule next note
            let adjustedDuration = Double(wave.noteDuration) / speedUpFactor
            let delayMicroseconds = Int(adjustedDuration * 1_000_000)
            let nextTime = DispatchTime.now() + DispatchTimeInterval.microseconds(delayMicroseconds)
            // Compute scheduled time in seconds and microseconds
            let scheduledNanos = nextTime.uptimeNanoseconds
            let scheduledSeconds = scheduledNanos / 1_000_000_000
            let scheduledMicroseconds = (scheduledNanos % 1_000_000_000) / 1_000

            print("â³ Scheduling note wave \(index + 1) at \(scheduledSeconds) sec, \(scheduledMicroseconds) Âµs")

            DispatchQueue.main.asyncAfter(deadline: nextTime) {
                scheduleWave(at: index + 1)
            }
        }

        // Start scheduling from the first wave
        DispatchQueue.main.asyncAfter(deadline: .now() + DispatchTimeInterval.milliseconds(Int(startDelay * 1000))) {
            scheduleWave(at: 0)
        }

    }

    func updateNotes() {
        var i = notesOnScreen.count - 1
        var waveCompleted = false

        while i >= 0 {
            notesOnScreen[i].y += notesOnScreen[i].speed
            if notesOnScreen[i].y > 550 {
                notesOnScreen.remove(at: i)
                waveCompleted = true
            }
            i -= 1
        }

        if waveCompleted {
            activeWaveIndex += 1
        }

        if activeWaveIndex >= noteWaves.count {
            showStartButton = true
            DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                audioManager.stopBackgroundMusic()
            }
        }
    }

    func handleKeyPress(_ event: NSEvent) {
        switch event.charactersIgnoringModifiers {
        
        case "A":
            if showStartButton {
                showStartButton = false
                startGame()
            }
        case "1":
            if showStartButton {
                selectedTrack = teen_back
                backgroundDelay = teen_bdelay
                noteFallingSpeed = teen_nfspeed
                startDelay = teen_sdelay
                speedUpFactor = teen_spfactor
                noteWaves = teen_spirit
            } else {
                pressedKeys.insert(1)
            }
        case "2":
            if showStartButton {
                selectedTrack = bohemian_back
                backgroundDelay = boh_bdelay
                noteFallingSpeed = boh_nfspeed
                startDelay = boh_sdelay
                speedUpFactor = boh_spfactor
                noteWaves = bohemian
            } else {
                pressedKeys.insert(2)
            }
        case "3":
            if showStartButton {
                selectedTrack = time_back
                backgroundDelay = time_bdelay
                noteFallingSpeed = time_nfspeed
                startDelay = time_sdelay
                speedUpFactor = time_spfactor
                noteWaves = time_floyd
            } else {
                pressedKeys.insert(3)
            }
        case "4": pressedKeys.insert(4)
        case " ": checkAndPlayWave()
        default: break
        }
    }

    func handleKeyRelease(_ event: NSEvent) {
        switch event.charactersIgnoringModifiers {
        case "1": pressedKeys.remove(1)
        case "2": pressedKeys.remove(2)
        case "3": pressedKeys.remove(3)
        case "4": pressedKeys.remove(4)
        case " ": return
        default: break
        }

        releaseNotes()
    }

    func releaseNotes() {
        print("releaseNotes")
        for midiNote in notesBeingPlayed {
            audioManager.stopNote(midiNote)
        }
        notesBeingPlayed.removeAll()
    }

    func checkAndPlayWave() {
        print("checkAndPlayWave")
        print("pressedKeys:", pressedKeys)
        
        guard let firstNote = notesOnScreen.first else { return }
        guard let wave = noteWaves.first(where: { $0.id == firstNote.waveID }) else { return }

        // Allow any superset (extra keys are fine)
        if pressedKeys.isSuperset(of: Set(wave.keys)) {
            for midiNote in wave.midiNotes {
                audioManager.playNote(midiNote, loudness: loudness, semitoneRange: wave.semitoneBend)
                notesBeingPlayed.append(midiNote)
            }
            notesOnScreen.removeAll { $0.waveID == wave.id }
            activeWaveIndex += 1
        }
    }
}
